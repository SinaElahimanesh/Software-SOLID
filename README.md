# گزارش روند انجام آزمایش

## طراحی مبتنی بر تست (Test Driven Development)

در این روش در ابتدا باید تست‌ها را بنویسیم و زمانی که هنوز روی کد بایاس نشده‌ایم و به این ترتیب پیاده‌سازی را انجام نداده‌ایم از روی دیزاین تست‌ها را می‌نویسیم و در ادامه سعی می‌كنیم اولا کدهایی بزنیم که باعث شوند تست‌ها پاس شوند و ثانیا سعی می‌کنیم که کدهایی که زده‌ایم را ریفکتور کنیم و در نتیجه به clean code در عین درست‌ بودن کارایی کد دست پیدا کنیم.

در ابتدا Intellij را نصب می‌کنیم و سپس یک پروژه‌ی مبتنی بر maven می‌سازیم. 
ساختار پروژه در نهایت به شرح زیر است:

<p align="center">
<img width="323" alt="Screenshot 1402-04-30 at 8 23 00 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/e218f853-a707-4fce-afeb-9803b7ab06f8">
</p>

سپس به maven دیپندنسی‌های لازم برای JUnit را به منظور تست اضافه می‌کنیم.

<p align="center">
<img width="860" alt="Screenshot 1402-04-30 at 8 24 00 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/2320fe1f-fb02-4d74-82a5-afd2be12a34d">
</p>

در مرحله‌ی بعد در ابتدا تست‌ها را می‌نویسیم. سعی می‌کنیم در نوشتن تست‌ها تا حد ممکن تست‌های متنوع و با اهداف متفاوت بنویسیم و به این ترتیب فضای ورودی را به صورت کامل پوشش دهیم که حداقل از هر افراز متنوعی از فضای ورودی تست‌های متناسب داشته باشیم.
لازم به ذکر است که انتظار داریم که اگر طول یا عرض مستصیل صفر یا منفی بود -۱ برگرداند که به این معنی است که ورودی معتبر نیست. 

<p align="center">
<img width="768" alt="Screenshot 1402-04-30 at 8 31 12 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/fe10a9d0-10f1-409f-95c3-68f4f82db52a">

<img width="785" alt="Screenshot 1402-04-30 at 8 27 37 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/d3114401-5abe-4e9e-a7cf-987b5abbeace">
</p>

حال به پیاده‌سازی کلاس Rectangle می‌پردازیم. به گونه‌ای که بتواند تست‌ها را پاس کند.

<p align="center">
<img width="451" alt="Screenshot 1402-04-30 at 8 29 04 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/479ca0c1-a2bc-4d5d-89c7-c7331939b479">
</p>

همانطور که در تصویر زیر می‌بینیم بخشی از تست‌ها فیل می‌شوند. چونکه انتظارمان در طراحی برای اعداد صفر و منفی را برآورده نکرده‌ایم.

<p align="center">
<img width="965" alt="Screenshot 1402-04-30 at 8 32 56 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/7abad1aa-8783-4f3f-9c5c-eb0efdf2d450">
</p>

در ادامه متد را به گونه‌ای تغییر می‌دهیم که تست‌ها پاس شوند.

<p align="center">
<img width="387" alt="Screenshot 1402-04-30 at 8 34 12 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/f881311f-6157-47de-b784-275a966ec3b3">
</p>

حال دوباره آن را اجرا می‌کنیم.

<p align="center">
<img width="937" alt="Screenshot 1402-04-30 at 8 34 55 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/791b9b34-bc2f-40d2-903d-2a81442ecf0a">
</p>

هنوز هم یک تست پاس نمی‌شود. به این ترتیب باید صفر بودن را هم پوشش دهیم.

<p align="center">
<img width="431" alt="Screenshot 1402-04-30 at 8 35 36 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/f9d84258-9ad6-4df5-89b3-ff144c55a487">

<img width="915" alt="Screenshot 1402-04-30 at 8 36 31 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/ba6f9e79-24ed-4958-99ee-54400968fba1">
</p>

بنابراین همه‌ی تست‌ها پاس می‌شوند.

حال به کلاس اولیه متد‌های ست و گت را اضافه می‌کنیم.

<p align="center">
<img width="368" alt="Screenshot 1402-04-30 at 8 37 36 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/4964f0cd-b119-4883-bd76-a971fab147c1">
</p>

در ادامه برای مربع تست می‌نویسیم.

<p align="center">
<img width="746" alt="Screenshot 1402-04-30 at 11 00 46 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/6288b44a-f5ac-4e4a-9b92-ac053ae8ca56">
</p>


در نهایت برای اینکه بتوانیم مربع را هم پوشش دهیم باید یک کلاس جدید ایجاد می‌کنیم.

<p align="center">
<img width="384" alt="Screenshot 1402-04-30 at 11 01 21 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/051af91d-95b1-4cb4-85a1-d13a0b4b5526">
</p>

حال تست‌ها را اجرا می‌کنیم.

<p align="center">
<img width="935" alt="Screenshot 1402-04-30 at 8 45 06 PM" src="https://github.com/SinaElahimanesh/Software-SOLID/assets/59636948/2490d705-d6b6-440d-8125-5c5483a011e1">
</p>

## اصول SOLID

در این طراحی سعی شده است اصول SOLID رعایت شود و تا حد ممکن سعی کنیم اصلی را نقض نکنیم. به عنوان نمونه اگر مربع را فرزند مستطیل قرار دهیم ممکن است LSP نقض شود. به گونه‌ای که اگر مربع را فرزند مستطیل قرار دهیم به یک مشکل میخوریم و آن هم این است که نمی‌توان کلاس پدر را با آن جایگزین کرد. چراکه مستطیل قابلیت تغییر طول و عرض را دارد. بنابراین ممکن است به عنوان نمونه در ابتدا از یک constructor با یک فیلد ورودی برای مربع استفاده کنیم و هم طول و هم عرض را یک چیز یکسان ست کنیم ولی ممکن است در آینده فردی یکی از این دو مقدار را تغییر دهد و به این ترتیب مربع بودن نقض می‌شود. از طرفی SRP هم رعایت شده است. هرکلاس فقط یک تک‌‌مسئولیت دارد. به عبارتی مثلا کلاس مستطیل فقط مسئولیت نگهداری یک مستطیل و محاسبه‌ی مساحت آن را دارد و کار اضافه‌ای انجام نمی‌دهد. از طرفی کلاس‌ها همگی در مقابل گسترش باز هستند و به سادگی شد به آنها متدهای get و set را اضافه کنیم بدون اینکه تغییر ناخواسته‌ای داشته باشیم یا نیاز به تغییر جایی را داشته باشیم.


# سوالات

**۱-** در این بخش به توضیح در مورد هریک از اصول SOLID می‌پردازیم.
الف) اصل SRP: این اصل به ما می‌گوید که باید هر کلاس یک مسئولیت مشخص داشته باشد. به عبارتی باید فقط به یک actor پاسخگو باشد و اگر این اصل را رعایت کنیم این اتفاق به ما کمک می‌کند که تا حد ممکن تغییر در یک کلاس باعث ایجاد تغییرات دیگر ناخواسته نشود و کلاس‌ها منعطف‌تر و قابل استفاده‌ی مجددتر باشند.

ب) اصل OCP: این اصل تاکید بر این دارد که باید کلاس‌ها در برابر توسعه‌ی جدید باز باشند ولی در برابر تغییر بسته. به این ترتیب باید بتوانیم یک کلاس را گسترش دهیم و موارد جدید را اضافه کنیم ولی در عین حال باید این کلاس اجازه‌ی ایجاد تغییرات دیگر را ندهد.

پ) اصل LSP: این اصل اشاره دارد که باید بتوان یک کلاس فرزند را با پدرش جایگزین کرد. به عبارتی باید یک کلاس فرزند از پدرش خواسته‌های بیشتری نداشته باشد و همچنین از پدر موارد کمتری را فراهم نکند. به این ترتیب باید بتوان بدون مشکل در کد جایگزینی را انجام داد.

ت) اصل ISP: این اصل به جدایی رابط‌ها اشاره دارد. به عبارتی تاکید می‌کند که باید سعی کنیم همواره رابط‌ها را جدا کنیم. این جدایی اینترفیس‌ها در مقابل اینکه تمامی اینترفیس‌ها در یک رابط قرار داده شده باشد به ما کمک می‌کند که بتوانیم با توجه به نیازمندی‌ها و به صورت مستقل رابط‌ها را تغییر دهیم.

ث) اصل DIP: این اصل باید تا حد ممکن سعی کنیم وابستگی به جزییات پیاده‌سازی را کاهش دهیم. به عبارتی باید سعی کنیم به گونه‌ای موارد مختلف را پیاده‌سازی کنیم که تا حد ممکن به انتزاع وابسته باشند و نه به پیاده‌سازی. این اصل به این اشاره دارد که در صورت رعایت این مورد می‌توان تغییرات را به سادگی اعمال کرد و وابستگی به جزییات سطح پایین کمتر شود.

**۲-** اصول SOLID در تمامی مراحل نرم‌افزار به کار می‌آیند. هرچند که در گام‌های طراحی و پیاده‌سازی مهم‌تر است که بتوانیم این اصول را رعایت کنیم تا بتوانیم به نرم‌افزاری با کیفیت بالاتر و منعطف‌تر در طول زمان برای ایجاد تغییرات و گسترش آن داشته باشیم.

**۳-** فرآیند توسعه نرم‌افزار یک فرآیند تکاملی است و به صورت iterative اکثرا انجام می‌شود. بنابراین هرچند در نگاه اول ممکن است اینگونه به نظر برسد که در فرآیند عادی توسعه نرم‌افزار که تست‌ها بعد از طراحی و پیاده‌سازی نوشته می‌شوند با حالت نوشتن برنامه بر اساس TDD تناقض دارند ولی هر دو روش با هم در مفهوم تشابه دارند. هردو بنابر این دارند که بتوانند نرم‌افزارهای بدون باگ بسازند به گونه‌ای که روش اول به صورت White Box تست می‌کند و روش دوم که TDD است به صورت Black Box تست می‌کند. در هر دو روش به صورت مداوم تاکید بر تست است و به این ترتیب هرچند ممکن است در نگاه اول متناقض به نظر برسند ولی در مفهوم تناقضی با یکدیگر ندارند.

**۴-** بله در این صورت ممکن بود. چراکه مربع یک نوع مستطیل است و به صورت کلی رابطه‌ی IS A بین آنها برقرار است. هرچند که این خطر وجود دارد که اگر در آینده نیاز باشد متدی برای تغییر ابعاد به کلاس پدر که مستطیل است اضافه کنیم، این مشکل به فرزند هم می‌رسید و اصل LSP نقض میشد. بنابراین این نوع ارث‌بری ممکن است در آینده برایمان مشکلاتی را ایجاد کند و توصیه نمی‌شود ولی اگر در این مورد مطمئن هستیم که هیچگاه نیاز به متد set نداریم مشکلی ندارد.








